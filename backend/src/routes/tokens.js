import express from "express";
import auth from "../middleware/auth.js";
import BookingToken from "../models/BookingToken.js";
import BookingRequest from "../models/BookingRequest.js";
import Payment from "../models/Payment.js";
import Message from "../models/Message.js";

const router = express.Router();

function randomCode(len = 10) {
  const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let out = "";
  for (let i = 0; i < len; i++) out += alphabet[Math.floor(Math.random() * alphabet.length)];
  return out;
}

// POST /api/tokens/generate
router.post("/generate", auth, async (req, res) => {
  try {
    const { bookingRequestId, expiresInHours = 72 } = req.body || {};
    const br = await BookingRequest.findById(bookingRequestId);
    if (!br) return res.status(404).json({ error: "Booking request not found" });
    if (String(br.owner) !== String(req.user.id)) {
      return res.status(403).json({ error: "Only venue owner can generate token" });
    }

    // Ensure a successful payment exists by owner for this bookingRequest
    const payment = await Payment.findOne({ bookingRequest: br._id, initiator: req.user.id, status: "success" });
    if (!payment) return res.status(400).json({ error: "Payment required before token generation" });

    const code = randomCode(12);
    const expiresAt = new Date(Date.now() + Number(expiresInHours) * 60 * 60 * 1000);
    const token = await BookingToken.create({
      code,
      venue: br.venue,
      requester: br.requester,
      owner: br.owner,
      bookingRequest: br._id,
      status: "active",
      expiresAt,
      payment: payment._id,
    });

    br.status = "token_generated";
    await br.save();

    // Send token in chat as a system message
    const io = req.app.get("io");
    const room = String(br.conversation || br._id);
    const saved = await Message.create({
      sender: req.user.id,
      room,
      text: `Booking token: ${code} (expires ${expiresAt.toISOString()})`,
    });
    const populatedMsg = await Message.findById(saved._id).populate("sender", "username avatar");
    if (io) io.to(room).emit("receive_message", populatedMsg);

    res.status(201).json(token);
  } catch (err) {
    console.error("Generate token error:", err);
    res.status(500).json({ error: "Failed to generate token" });
  }
});

// POST /api/tokens/verify
router.post("/verify", auth, async (req, res) => {
  try {
    const { code } = req.body || {};
    if (!code) return res.status(400).json({ error: "code required" });
    const token = await BookingToken.findOne({ code }).populate("venue");
    if (!token) return res.status(404).json({ error: "Token not found" });
    if (token.status !== "active") return res.status(400).json({ error: "Token is not active" });
    if (new Date() > token.expiresAt) return res.status(400).json({ error: "Token has expired" });
    // Token must be tied to current requester
    if (String(token.requester) !== String(req.user.id)) return res.status(403).json({ error: "Token not issued to this user" });

    res.json({ valid: true, venue: token.venue, token: { code: token.code, expiresAt: token.expiresAt } });
  } catch (err) {
    console.error("Verify token error:", err);
    res.status(500).json({ error: "Failed to verify token" });
  }
});

export default router;
// List tokens generated by venue owner
router.get('/my/generated', auth, async (req, res) => {
  try {
    const list = await BookingToken.find({ owner: req.user.id })
      .sort({ createdAt: -1 })
      .populate('venue')
      .populate('requester', 'username avatar');
    res.json({ tokens: list });
  } catch (err) {
    console.error('List my generated tokens error:', err);
    res.status(500).json({ error: 'Failed to fetch tokens' });
  }
});

// List tokens received by event creator
router.get('/my/received', auth, async (req, res) => {
  try {
    const list = await BookingToken.find({ requester: req.user.id })
      .sort({ createdAt: -1 })
      .populate('venue')
      .populate('owner', 'username avatar');
    res.json({ tokens: list });
  } catch (err) {
    console.error('List my received tokens error:', err);
    res.status(500).json({ error: 'Failed to fetch tokens' });
  }
});
